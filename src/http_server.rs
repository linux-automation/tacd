// This file is part of tacd, the LXA TAC system daemon
// Copyright (C) 2022 Pengutronix e.K.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

use std::fs::write;
use std::net::TcpListener;

use anyhow::{Context, Result};
use tide::{Body, Response, Server};

mod serve_dir;
use serve_dir::serve_dir;

#[cfg(feature = "demo_mode")]
mod consts {
    pub const WEBUI_DIR: &str = "web/build";
    pub const EXTRA_DIR: &str = "demo_files/srv/www";
    pub const FS_PREFIX: &str = "demo_files";
    pub const FALLBACK_PORT: &str = "[::]:8080";
}

#[cfg(not(feature = "demo_mode"))]
mod consts {
    pub const WEBUI_DIR: &str = "/usr/share/tacd/webui";
    pub const EXTRA_DIR: &str = "/srv/www";
    pub const FS_PREFIX: &str = "";
    pub const FALLBACK_PORT: &str = "[::]:80";
}

use consts::{EXTRA_DIR, FALLBACK_PORT, FS_PREFIX, WEBUI_DIR};

// openapi.json is generated by build.rs from openapi.yaml
const OPENAPI_JSON: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/openapi.json"));

// Files that should be read-/writeable from the webinterface
const EXPOSED_FILES_RW: &[(&str, &str)] = &[
    (
        "/etc/labgrid/configuration.yaml",
        "/v1/labgrid/configuration",
    ),
    ("/etc/labgrid/environment", "/v1/labgrid/environment"),
    ("/etc/labgrid/userconfig.yaml", "/v1/labgrid/userconfig"),
];

pub struct HttpServer {
    listeners: Vec<TcpListener>,
    pub server: Server<()>,
}

impl HttpServer {
    pub fn new() -> Result<Self> {
        let mut server = Self {
            listeners: Vec::new(),
            server: tide::new(),
        };

        // Open [::]:80 / [::]:8080. This, somewhat confusingly also listens on
        // 0.0.0.0 and not only on IPv6.
        server
            .listeners
            .push(TcpListener::bind(FALLBACK_PORT).with_context(|| {
                "Could not bind web API to port, is there already another service running?"
            })?);

        server.expose_openapi_json();
        server.expose_dir(WEBUI_DIR, "/", false);
        server.expose_dir(EXTRA_DIR, "/srv", true);

        for (fs_path, web_path) in EXPOSED_FILES_RW {
            let fs_path = FS_PREFIX.to_owned() + *fs_path;
            server.expose_file_rw(fs_path, web_path)?;
        }

        Ok(server)
    }

    /// Serve a compiled-in openapi.json file
    fn expose_openapi_json(&mut self) {
        self.server.at("/v1/openapi.json").get(|_req| async move {
            let body = Body::from_bytes(OPENAPI_JSON.into());
            let response = Response::builder(200)
                .body(body)
                .content_type("application/json")
                .build();

            Ok(response)
        });
    }

    /// Serve a directory from disk for reading
    fn expose_dir(&mut self, fs_path: &'static str, web_path: &str, directory_listings: bool) {
        let handler = move |req| async move { serve_dir(fs_path, directory_listings, req).await };

        self.server.at(web_path).get(handler);
        self.server.at(web_path).at("").get(handler);
        self.server.at(web_path).at("*rel_path").get(handler);
    }

    /// Serve a file from disk for reading and writing
    fn expose_file_rw(&mut self, fs_path: String, web_path: &str) -> Result<()> {
        self.server.at(web_path).serve_file(&fs_path)?;

        self.server
            .at(web_path)
            .put(move |mut req: tide::Request<()>| {
                let fs_path = fs_path.clone();

                async move {
                    let content = req.body_bytes().await?;
                    write(&fs_path, content)?;

                    Ok(Response::new(204))
                }
            });
        Ok(())
    }

    pub async fn serve(self) -> Result<()> {
        self.server.listen(self.listeners).await?;
        Ok(())
    }
}
